			Report

Implementation of Timestamp-ordering protocol

Category: Timestamp-ordering protocol for concurrency control in database system

Introduction:
When several transactions execute concurrently in database, the isolation property is no longer preserved. To ensure it, the system must control interaction among concurrent transactions. It is achieved through concurrency control schemes. Timestamp ordering protocol is one such concurrency control scheme.

Timestamp ordering protocol associates a unique fixed timestamp with each transaction. These timestamps determine the serializability order. Also, each data item Q involved in transaction is associated with two time stamp values namely W-timestamp(Q) and R-timestamp(Q). These timestamps are updated whenever a new read(Q) or write(Q) instruction is executed by any transaction as per protocol specified.

In this project, an implementation of timestamp ordering protocol is presented. The implementation takes a concurrent schedule as input in form of a text file and generates a log file which contains details of execution of the instructions present in input file line by line. The log provides a comprehensive output which details updates performed on timestamps of data by various transactions. It also provides details about the instruction that caused rollback and the transactions rolled back due to it. The log file can be used to differentiate schedules allowed by timestamp ordering protocol from those which contain conflicting transactions. It can also be used to know internal details of execution of schedule.


Implementation
In this project, logical counter is used to assign timestamp to each new transaction. The value of logical_counter is assigned to each new transaction that enters the system and incremented thereafter. The details of R-timestamp and W-timestamp of each unique data item are maintained in map data structures namely “data_rmap” and “data_wmap” respectively. Whenever a new data item is detected, it is inserted into map with initial value of timestamp zero. The value of these data timestamps is updated as per the specifications of protocol at runtime. A function writelogfile(“”) is used to write to log file wherever necessary. The format of log entry is as follows.
An entryin log file is a statement followed by its affect on the system as per the protocol.Thus
T1:read(A)
Read timestamp of A updated to 1 by transaction 1
Implies that a read operation was carried out by transaction 1 on data item A and its affect was to update the read timestamp of data time A to 1 which is the timestamp of T1.
If a transaction conflicts with Timestamp based ordering, it is rolled back as per the specifications of protocol. However, this rollback can trigger additional rollbacks (called cascading rollbacks) of transactions which have read dirty data from current transaction. To take cascading rollback into consideration, a matrix named “dirty_read” is maintained. An entry [i][j] in the matrix is 1 if a transaction T[j] has read any data item written by T[i] and 0 otherwise. If a transaction T[i] rolls back, then all transactions which have T[i][j]=1 for 0<j<ntrans+1 are rolled back recursively as per the mentioned definition. It is reflected in log file as required.


Result
Two different inputs are used to test the functioning of implementation. The log file generated by running schedule “input1.txt” reflected that the schedule has a problem of cascading rollback near its end. On the contrary the log file of “input2.txt” showed no rollbacks and completed till end without trouble. These results match with the expected behavior of timestamp ordering protocol. 

Conclusion and future work
Timestamp based ordering protocol resolves the problem of concurrent execution while maintaining isolation in database system. It ensures freedom from deadlock as it doesn’t allow waiting. However, it can generate schedules which are not recoverable or cascade less. The implementation provided in this project can be used to gain insight into step by step updates made by protocol and to test behavior of a schedule with this protocol.










